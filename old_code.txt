export const initializeNotifications = async (dogName) => {
  try {
    // Configurer le handler
    configureNotificationHandler();

    // Demander les permissions avec un timeout de 5 secondes
    const permissionPromise = requestNotificationPermissions();
    const hasPermission = await Promise.race([
      permissionPromise,
      new Promise(resolve => setTimeout(() => resolve(false), 5000))
    ]);

    if (!hasPermission) {
      console.log(' Permissions notifications refusées ou timeout');
      return false;
    }

    // Charger les paramètres avec un timeout
    const settingsPromise = loadNotificationSettings();
    const settings = await Promise.race([
      settingsPromise,
      new Promise(resolve => setTimeout(() => resolve(DEFAULT_NOTIFICATION_SETTINGS), 3000))
    ]);

    // Vérifier si c'est la première fois (AsyncStorage vide = première utilisation)
    const isFirstTime = await AsyncStorage.getItem('notificationInitialized');

    if (!isFirstTime) {
      // Première fois : programmer les notifications EN ARRIÈRE-PLAN (non-bloquant)
      console.log(' Programmation initiale des notifications (en arrière-plan)');
      scheduleReminders(dogName, settings).catch(error => {
        console.error(' Erreur programmation arrière-plan:', error);
      });
      await AsyncStorage.setItem('notificationInitialized', 'true');
    } else {
      console.log(' Notifications déjà initialisées');
    }

    return true;
  } catch (error) {
    console.error(' Erreur initialisation notifications:', error);
    return false;
  }
};
