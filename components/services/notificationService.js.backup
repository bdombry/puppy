/**
 * Service de gestion des notifications programm√©es par jour
 * Chaque jour de la semaine a ses propres heures ind√©pendantes
 */

import * as Notifications from 'expo-notifications';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Jours de la semaine
const DAYS_OF_WEEK = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche'];

// Configuration par d√©faut : m√™me heures pour tous les jours
export const DEFAULT_NOTIFICATION_SETTINGS = {
  enabled: true,
  days: {
    lundi: { enabled: true, times: [9, 11, 14, 18, 21] },
    mardi: { enabled: true, times: [9, 11, 14, 18, 21] },
    mercredi: { enabled: true, times: [9, 11, 14, 18, 21] },
    jeudi: { enabled: true, times: [9, 11, 14, 18, 21] },
    vendredi: { enabled: true, times: [9, 11, 14, 18, 21] },
    samedi: { enabled: true, times: [9, 11, 14, 18, 21] },
    dimanche: { enabled: true, times: [9, 11, 14, 18, 21] },
  },
};

// Templates pr√©d√©finis par √¢ge du chiot
export const PUPPY_PRESETS = {
  'young': { // 2-3 mois
    label: 'üê∂ Chiot 2-3 mois',
    description: 'Toutes les 2h',
    times: [8, 10, 12, 14, 16, 18, 20, 22],
  },
  'medium': { // 4-6 mois
    label: 'üêï Chiot 4-6 mois',
    description: 'Toutes les 3h',
    times: [7, 10, 13, 16, 19, 22],
  },
  'older': { // 6+ mois
    label: 'üêï‚Äçü¶∫ Chien 6+ mois',
    description: 'Toutes les 4h',
    times: [6, 10, 14, 18, 22],
  },
};

const STORAGE_KEY = 'notificationSettings';

/**
 * Migre les anciennes donn√©es vers le nouveau format
 */
const migrateOldSettings = (oldSettings) => {
  // Si le format est d√©j√† le nouveau, retourner tel quel
  if (oldSettings.days && typeof oldSettings.days === 'object') {
    return oldSettings;
  }

  // Sinon, c'est l'ancien format, migrer
  console.log('üîÑ Migration des anciens param√®tres...');
  
  // G√©n√©rer les heures par d√©faut depuis les anciens param√®tres
  let times = [];
  if (oldSettings.useCustom && oldSettings.customTimes) {
    times = oldSettings.customTimes;
  } else if (oldSettings.startHour !== undefined) {
    for (let h = oldSettings.startHour; h <= oldSettings.endHour; h += oldSettings.intervalHours) {
      times.push(h);
    }
  } else {
    times = [9, 11, 14, 18, 21]; // Par d√©faut
  }

  // Cr√©er le nouveau format
  const newSettings = JSON.parse(JSON.stringify(DEFAULT_NOTIFICATION_SETTINGS));
  for (const day of DAYS_OF_WEEK) {
    newSettings.days[day].times = times;
    newSettings.days[day].enabled = oldSettings.enabled !== false;
  }

  console.log('‚úÖ Migration r√©ussie');
  return newSettings;
};

/**
 * Configure le handler des notifications
 */
export const configureNotificationHandler = () => {
  Notifications.setNotificationHandler({
    handleNotification: async () => ({
      shouldShowBanner: true,
      shouldShowList: true,
      shouldPlaySound: true,
      shouldSetBadge: true,
    }),
  });
};

/**
 * Demande les permissions de notification
 */
export const requestNotificationPermissions = async () => {
  try {
    const { status } = await Notifications.requestPermissionsAsync();
    console.log('‚úÖ Status permission notifications:', status);
    return status === 'granted';
  } catch (error) {
    console.error('‚ùå Erreur demande permission notifications:', error);
    return false;
  }
};

/**
 * Convertir jour de la semaine en num√©ro (0 = dimanche, ..., 6 = samedi)
 */
const getDayNumber = (dayName) => {
  const dayMap = {
    dimanche: 0,
    lundi: 1,
    mardi: 2,
    mercredi: 3,
    jeudi: 4,
    vendredi: 5,
    samedi: 6,
  };
  return dayMap[dayName.toLowerCase()];
};

/**
 * Programme les notifications selon les param√®tres par jour
 */
export const scheduleReminders = async (dogName, settings) => {
  try {
    console.log('üìÖ Programmation notifications par jour:', settings);

    // 1. Supprimer les anciennes notifications
    const scheduled = await Notifications.getAllScheduledNotificationsAsync();
    for (let notif of scheduled) {
      await Notifications.cancelScheduledNotificationAsync(notif.identifier);
    }
    console.log('üóëÔ∏è Anciennes notifs supprim√©es:', scheduled.length);

    // 2. Si d√©sactiv√©, arr√™ter
    if (!settings.enabled) {
      console.log('‚è∏Ô∏è Notifications d√©sactiv√©es');
      return;
    }

    // 3. Programmer les notifications pour chaque jour
    let totalScheduled = 0;
    for (const dayName of DAYS_OF_WEEK) {
      const dayConfig = settings.days[dayName];
      
      if (!dayConfig || !dayConfig.enabled || !dayConfig.times || dayConfig.times.length === 0) {
        console.log(`‚è∏Ô∏è ${dayName}: aucune notification`);
        continue;
      }

      const dayNumber = getDayNumber(dayName);

      for (const hour of dayConfig.times) {
        try {
          await Notifications.scheduleNotificationAsync({
            content: {
              title: `Sortie de ${dogName} ! üê∂`,
              body: `C'est l'heure pour une balade ‚ú®`,
              sound: 'default',
              badge: 1,
            },
            trigger: {
              weekday: dayNumber,
              hour,
              minute: 0,
              repeats: true,
            },
          });
          totalScheduled++;
        } catch (error) {
          console.error(`‚ùå Erreur programmation ${dayName} ${hour}h:`, error);
        }
      }

      console.log(`‚úÖ ${dayName}: ${dayConfig.times.length} notification(s)`);
    }

    console.log(`‚úÖ Total ${totalScheduled} notifications programm√©es`);
  } catch (error) {
    console.error('‚ùå Erreur scheduleReminders:', error);
  }
};

/**
 * Charge les param√®tres de notification depuis le stockage
 */
export const loadNotificationSettings = async () => {
  try {
    const saved = await AsyncStorage.getItem(STORAGE_KEY);
    if (saved) {
      const settings = JSON.parse(saved);
      // Migrer si n√©cessaire
      const migratedSettings = migrateOldSettings(settings);
      console.log('üìÇ Param√®tres charg√©s');
      return migratedSettings;
    }
    console.log('üìÇ Utilisation des param√®tres par d√©faut');
    return JSON.parse(JSON.stringify(DEFAULT_NOTIFICATION_SETTINGS));
  } catch (error) {
    console.error('‚ùå Erreur chargement param√®tres:', error);
    return JSON.parse(JSON.stringify(DEFAULT_NOTIFICATION_SETTINGS));
  }
};

/**
 * Sauvegarde les param√®tres de notification
 */
export const saveNotificationSettings = async (settings) => {
  try {
    await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    console.log('üíæ Param√®tres sauvegard√©s');
    return true;
  } catch (error) {
    console.error('‚ùå Erreur sauvegarde param√®tres:', error);
    return false;
  }
};

/**
 * Initialise les notifications au d√©marrage de l'app (non-bloquant)
 */
export const initializeNotifications = async (dogName) => {
  try {
    // Configurer le handler
    configureNotificationHandler();

    // Demander les permissions avec un timeout de 5 secondes
    const permissionPromise = requestNotificationPermissions();
    const hasPermission = await Promise.race([
      permissionPromise,
      new Promise(resolve => setTimeout(() => resolve(false), 5000))
    ]);

    if (!hasPermission) {
      console.log('‚ö†Ô∏è Permissions notifications refus√©es ou timeout');
      return false;
    }

    // Charger les param√®tres avec un timeout
    const settingsPromise = loadNotificationSettings();
    const settings = await Promise.race([
      settingsPromise,
      new Promise(resolve => setTimeout(() => resolve(DEFAULT_NOTIFICATION_SETTINGS), 3000))
    ]);
    
    // V√©rifier si c'est la premi√®re fois (AsyncStorage vide = premi√®re utilisation)
    const isFirstTime = await AsyncStorage.getItem('notificationInitialized');
    
    if (!isFirstTime) {
      // Premi√®re fois : programmer les notifications EN ARRI√àRE-PLAN (non-bloquant)
      console.log('üì± Programmation initiale des notifications (en arri√®re-plan)');
      scheduleReminders(dogName, settings).catch(error => {
        console.error('‚ö†Ô∏è Erreur programmation arri√®re-plan:', error);
      });
      await AsyncStorage.setItem('notificationInitialized', 'true');
    } else {
      console.log('‚úÖ Notifications d√©j√† initialis√©es');
    }

    return true;
  } catch (error) {
    console.error('‚ùå Erreur initialisation notifications:', error);
    return false;
  }
};

/**
 * Met √† jour et reprogramme les notifications (avec flag pour √©viter les tests)
 */
export const updateNotificationSettings = async (dogName, newSettings, testNotification = false) => {
  try {
    // Sauvegarder
    await saveNotificationSettings(newSettings);

    // Toujours supprimer les anciennes
    const scheduled = await Notifications.getAllScheduledNotificationsAsync();
    for (let notif of scheduled) {
      await Notifications.cancelScheduledNotificationAsync(notif.identifier);
    }
    console.log(`üóëÔ∏è ${scheduled.length} anciennes notifs supprim√©es`);

    // Reprogrammer les nouvelles SANS envoyer de notif de test
    await scheduleReminders(dogName, newSettings);

    // Envoyer UNE seule notification de test si demand√©
    if (testNotification) {
      await Notifications.scheduleNotificationAsync({
        content: {
          title: `Notification test ! üéâ`,
          body: `Param√®tres sauvegard√©s avec succ√®s`,
          sound: 'default',
        },
        trigger: { seconds: 1 },
      });
      console.log('‚úÖ Notification de test envoy√©e');
    }

    console.log('‚úÖ Notifications mises √† jour');
    return true;
  } catch (error) {
    console.error('‚ùå Erreur mise √† jour notifications:', error);
    return false;
  }
};

/**
 * D√©sactive temporairement les notifications
 */
export const disableNotificationsUntil = async (durationMinutes) => {
  try {
    const scheduled = await Notifications.getAllScheduledNotificationsAsync();
    for (let notif of scheduled) {
      await Notifications.cancelScheduledNotificationAsync(notif.identifier);
    }
    console.log(`‚è∏Ô∏è Notifications d√©sactiv√©es pour ${durationMinutes} min`);

    // R√©activer apr√®s la dur√©e
    setTimeout(async () => {
      const settings = await loadNotificationSettings();
      const dogName = await AsyncStorage.getItem('dogName') || 'ton chiot';
      await scheduleReminders(dogName, settings);
      console.log('üîî Notifications r√©activ√©es');
    }, durationMinutes * 60 * 1000);

    return true;
  } catch (error) {
    console.error('‚ùå Erreur d√©sactivation notifications:', error);
    return false;
  }
};

/**
 * Applique un preset d'√¢ge du chiot
 */
export const applyPuppyPreset = (presetKey, settings) => {
  const preset = PUPPY_PRESETS[presetKey];
  if (!preset) return settings;

  const newSettings = JSON.parse(JSON.stringify(settings));
  for (const day of DAYS_OF_WEEK) {
    newSettings.days[day].times = [...preset.times];
  }
  return newSettings;
};

